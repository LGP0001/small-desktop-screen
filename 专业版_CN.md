[English](专业版_EN.md) | 中文

# 任务创建专业版

## 任务管理

理解FreeRTOS中的任务管理是掌握任务创建与调度的基础

### 处理时间分配：   
FreeRTOS 是一个抢占式实时操作系统，它通过时间片轮转（time slicing）和任务优先级来管理处理时间的分配。每个任务都被赋予一个优先级，并且在同一优先级的多个任务之间，可以通过时间片轮转来共享处理器时间。

- 时间片轮转：  
如果启用了时间片轮转，同一优先级的任务将在每个时间片期间交替运行。每个任务在一个时间片内运行，然后控制权传递给下一个同优先级的任务。这确保了同一优先级的所有任务都能得到处理时间。

### 任务选择和运行：  
FreeRTOS 的调度器（Scheduler）负责决定哪个任务应该在任何给定时刻运行。它通常采用优先级调度算法来决定任务运行的顺序。

- 优先级调度：  
每个任务都有一个与之关联的优先级。调度器总是选择最高优先级的就绪任务来运行。如果有多个最高优先级的就绪任务，调度器将根据所选择的调度策略（例如时间片轮转）在它们之间共享处理器时间。

### 任务优先级对系统行为的影响：  
任务优先级影响系统行为的方式主要表现在以下几点：

- 任务抢占：  
高优先级的任务可以抢占低优先级的任务。也就是说，当一个高优先级的任务变为就绪状态时，它可以立即得到运行，即使低优先级的任务正在运行。

- 优先级反转：  
优先级反转是实时系统中一个常见的问题，它发生在低优先级任务持有一个高优先级任务需要的资源时。FreeRTOS 提供了优先级继承协议来解决优先级反转问题。

### 任务状态：
任务的状态是描述任务当前处于何种条件或阶段的方式。在FreeRTOS中，任务可以存在于以下几种状态：

- 就绪（Ready）：
在此状态下，任务已准备好运行，但正在等待调度器的调度。

- 运行（Running）：
任务当前正在执行其代码。

- 阻塞（Blocked）：
任务在等待某个条件成立，例如等待一段时间或等待某个事件发生，它不会消耗处理器时间。

- 挂起（Suspended）：
任务被暂时停止，不会被调度器调度，直至被明确恢复为止。

- 删除（Deleted）：
任务被删除，不再存在于系统中。

每种状态对应任务在系统中的不同阶段，理解任务的状态对于理解任务的生命周期和系统的行为至关重要。

## 队列管理

基于 FreeRTOS 的应用程序由一组独立的任务构成——每个任务都是具有独立权
限的小程序。这些独立的任务之间很可能会通过相互通信以提供有用的系统功能。
FreeRTOS 中所有的通信与同步机制都是基于队列实现的。

### 创建队列

在 FreeRTOS 中，队列是通过调用 xQueueCreate() 函数来创建的。创建队列时，你需要指定队列能够持有的元素数量以及每个元素的大小。
~~~c
QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );
~~~
- uxQueueLength: 这个参数指定队列可以持有的最大元素数量。
- uxItemSize: 这个参数指定每个元素的大小（字节）。

###  队列的数据管理

队列在内部使用先进先出（FIFO）原则来管理数据。这意味着第一个被发送到队列的数据将是第一个被从队列接收的数据。

###  向队列发送数据

可以使用 xQueueSend() 或 xQueueSendToFront() 函数将数据发送到队列。
~~~c
BaseType_t xQueueSend( QueueHandle_t xQueue, const void * pvItemToQueue, TickType_t xTicksToWait );
~~~
- xQueue: 队列句柄，它指定要发送数据的队列。
- pvItemToQueue: 一个指向要发送数据的指针。
- xTicksToWait: 如果队列已满，这个参数指定任务应该阻塞多长时间等待队列空间可用。

### 从队列接收数据

可以使用 xQueueReceive() 函数从队列接收数据。
~~~c
BaseType_t xQueueReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );
~~~
- xQueue: 队列句柄，它指定要接收数据的队列。
- pvBuffer: 一个指向接收数据缓冲区的指针。
- xTicksToWait: 如果队列为空，这个参数指定任务应该阻塞多长时间等待数据可用。

### 队列阻塞
队列阻塞是指当任务试图从空队列接收数据或向已满的队列发送数据时，任务将进入阻塞状态，等待队列变得可用。

### 任务优先级的影响
当多个任务试图访问同一队列时，高优先级的任务将先获得访问权。同时，在往队列发送和从队列接收数据时，高优先级的任务也有可能抢占低优先级的任务。通过合理设置任务优先级和使用队列，可以实现任务间的有效通信和同步。

## 中断管理

### 可在中断服务例程中使用的 FreeRTOS API

FreeRTOS 提供了一些专为中断服务例程（ISR）设计的 API 函数。这些函数通常以 "FromISR" 结尾，例如 xQueueSendFromISR()、xSemaphoreGiveFromISR() 等。使用这些 API 可以确保在 ISR 中安全地与 FreeRTOS 对象交互，如队列和信号量。

### 延迟中断方案

延迟中断是指在 ISR 中仅设置一个标志，然后在较低优先级的代码中处理中断。这种方案可以最小化中断处理时间，从而改善系统实时性。在 FreeRTOS 中，通常可以使用二值信号量或直接任务通知实现延迟中断处理。

### 创建和使用二值信号量与计数信号量
- 二值信号量：使用 xSemaphoreCreateBinary() 创建，主要用于同步和互斥。
- 计数信号量：使用 xSemaphoreCreateCounting() 创建，可用于跟踪资源计数。

### 二值信号量和计数信号量之间的区别
二值信号量只能有两个状态（0或1），而计数信号量可以有更多状态，用于跟踪可用资源的数量。

### 利用队列在中断服务例程中传递数据

通过 xQueueSendFromISR() 和 xQueueReceiveFromISR() 函数，可以在 ISR 中向队列发送数据和从队列接收数据，实现 ISR 和任务之间的通信。

### FreeRTOS 中断嵌套模型

FreeRTOS 支持中断嵌套，这意味着高优先级的中断可以打断正在执行的低优先级中断。中断嵌套模型的实现依赖于特定的硬件和编译器。

## 资源管理

多任务系统中存在一种潜在的风险。当一个任务在使用某个资源的过程中，即还没有完全结束对资源的访问时，便被切出运行态，使得资源处于非一致，不完整的状态。如果这个时候有另一个任务或者中断来访问这个资源，则会导致数据损坏或是其它相似
的错误。

### 资源管理的必要性

在一个多任务系统中，资源管理是确保系统稳定运行的重要组成部分。当多个任务试图访问共享资源时，需要通过某种机制来控制对资源的访问，以避免数据冲突和不一致。

### 临界区

临界区是指在代码中临时禁止中断，以保护对共享资源的访问。在进入临界区之前会禁止中断，在退出时恢复中断。FreeRTOS 提供了 taskENTER_CRITICAL() 和 taskEXIT_CRITICAL() 函数来实现临界区的保护。

### 互斥

互斥是一种同步机制，用于确保在任何时候只有一个任务可以访问共享资源。通常通过互斥量(mutex)来实现。

### 挂起调度器

挂起调度器意味着暂时停止任务切换，通常用于保护短临界区。FreeRTOS 提供了 vTaskSuspendAll() 和 xTaskResumeAll() 函数来挂起和恢复调度器。

### 使用互斥量

FreeRTOS 提供了 xSemaphoreCreateMutex() 函数来创建一个互斥量，并通过 xSemaphoreTake() 和 xSemaphoreGive() 函数来获取和释放互斥量。

### 创建与使用守护任务

守护任务通常用于在系统中执行后台处理或清理工作。可以使用 xTaskCreate() 函数创建守护任务，并设置较低的优先级，以确保它不会阻塞其他重要任务。

### 优先级反转与优先级继承

- 优先级反转是指低优先级任务持有共享资源时，阻止了高优先级任务的执行，可能导致系统响应延迟。
- 优先级继承是一种减轻优先级反转问题的技术，当高优先级任务等待低优先级任务释放资源时，低优先级任务临时继承高优先级任务的优先级，以加速资源的释放。
## 内存管理

### FreeRTOS的内存分配时机
FreeRTOS的内存分配主要发生在以下几个时刻：

- 任务创建：当创建一个新的任务时，FreeRTOS会为该任务分配必要的内存。这包括任务控制块（TCB）和任务堆栈的内存分配。
- 队列、信号量和互斥量创建：在创建队列、信号量或互斥量时，FreeRTOS会分配必要的内存来存储这些对象的管理信息。
- 动态内存分配：如果使用FreeRTOS的动态内存管理功能，例如pvPortMalloc()和vPortFree()，在运行时可以动态分配和释放内存。
- 延迟分配：例如，在某些情况下，可能需要延迟分配内存，直到确实需要内存时才分配。
- 中断服务例程（ISR）：在某些情况下，中断服务例程可能也会需要分配内存，例如，将数据项发送到队列或信号量。

